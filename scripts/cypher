#!/usr/bin/env python

# Copyright 2011 Nigel Small
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Cypher command line tool
"""

__author__    = "Nigel Small <py2neo@nigelsmall.org>"
__copyright__ = "Copyright 2011 Nigel Small"
__license__   = "Apache License, Version 2.0"


import argparse
try:
    import json
except ImportError:
    import simplejson as json
from py2neo import neo4j, cypher
import sys


def _stringify(value, quoted=False, with_properties=False):
    if isinstance(value, neo4j.Node):
        out = str(value)
        if quoted:
            out = '"' + out + '"'
        if with_properties:
            out += " " + json.dumps(value._lookup('data'), separators=(',',':'))
    elif isinstance(value, neo4j.Relationship):
        out = str(value.get_start_node()) + str(value) + str(value.get_end_node())
        if quoted:
            out = '"' + out + '"'
        if with_properties:
            out += " " + json.dumps(value._lookup('data'), separators=(',',':'))
    else:
        if quoted:
            out = json.dumps(value)
        else:
            out = str(value)
    return out

def execute_and_output_as_delimited(graph_db, query, field_delimiter="\t", out=None, err=None):
    out = out or sys.stdout
    err = err or sys.stderr
    def on_error(message):
        err.write(message)
        if not message.endswith("\n"):
            err.write("\n")
    data, metadata = cypher.execute(graph_db, query, error_handler=on_error)
    out.write(field_delimiter.join([
    json.dumps(column)
    for column in metadata.columns
    ]))
    out.write("\n")
    for row in data:
        out.write(field_delimiter.join([
        _stringify(value, quoted=True)
        for value in row
        ]))
        out.write("\n")

def execute_and_output_as_json(graph_db, query, out=None, err=None):
    out = out or sys.stdout
    err = err or sys.stderr
    def on_error(message):
        err.write(message)
        if not message.endswith("\n"):
            err.write("\n")
    data, metadata = cypher.execute(graph_db, query, error_handler=on_error)
    columns = [json.dumps(column) for column in metadata.columns]
    row_count = 0
    out.write("[\n")
    for row in data:
        row_count += 1
        if row_count > 1:
            out.write(",\n")
        out.write("\t{" + ", ".join([
        columns[i] + ": " + _stringify(row[i], quoted=True)
        for i in range(len(row))
        ]) + "}")
    out.write("\n]\n")

def execute_and_output_as_geoff(graph_db, query, out=None, err=None):
    out = out or sys.stdout
    err = err or sys.stderr
    nodes = {}
    relationships = {}
    def on_error(message):
        err.write(message)
        if not message.endswith("\n"):
            err.write("\n")
    def update_descriptors(value):
        if isinstance(value, neo4j.Node):
            nodes[str(value)] = value._lookup('data')
        elif isinstance(value, neo4j.Relationship):
            relationships[str(value.get_start_node()) + str(value) + str(value.get_end_node())] = value._lookup('data')
        else:
            # property - not supported in GEOFF format, so ignore
            pass
    data, columns = cypher.execute(graph_db, query, error_handler=on_error)
    for row in data:
        for i in range(len(row)):
            update_descriptors(row[i])
    for key, value in nodes.items():
        out.write("{0} {1}\n".format(
            key,
            json.dumps(value)
        ))
    for key, value in relationships.items():
        out.write("{0} {1}\n".format(
            key,
            json.dumps(value)
        ))

def execute_and_output_as_text(graph_db, query, out=None, err=None):
    out = out or sys.stdout
    err = err or sys.stderr
    def on_error(message):
        err.write(message)
        if not message.endswith("\n"):
            err.write("\n")
    data, metadata = cypher.execute(graph_db, query, error_handler=on_error)
    columns = metadata.columns
    column_widths = [len(column) for column in columns]
    for row in data:
        column_widths = [
            max(column_widths[i], None if row[i] is None else len(_stringify(row[i], with_properties=True)))
            for i in range(len(row))
        ]
    out.write("+-" + "---".join([
        "".ljust(column_widths[i], "-")
        for i in range(len(columns))
    ]) + "-+\n")
    out.write("| " + " | ".join([
        columns[i].ljust(column_widths[i])
        for i in range(len(columns))
    ]) + " |\n")
    out.write("+-" + "---".join([
        "".ljust(column_widths[i], "-")
        for i in range(len(columns))
    ]) + "-+\n")
    for row in data:
        out.write("| " + " | ".join([
            _stringify(row[i], with_properties=True).ljust(column_widths[i])
            for i in range(len(row))
        ]) + " |\n")
    out.write("+-" + "---".join([
        "".ljust(column_widths[i], "-")
        for i in range(len(columns))
    ]) + "-+\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Execute Cypher queries against a Neo4j database server and output the results.")
    parser.add_argument("-H", "--host", metavar="host", default='localhost', help="Neo4j server host name")
    parser.add_argument("-P", "--port", metavar="port", default=7474, help="Neo4j server port")
    parser.add_argument("-D", "--database-path", metavar="path", default='/db/data/', help="path of graph database (e.g. /db/data/)")
    parser.add_argument("-f", "--format", metavar="format", default='text', help="output file format")
    #parser.add_argument("-n", "--no-header", metavar="no_header", default=False, help="header suppression flag")
    parser.add_argument("query", help="the Cypher query to execute")
    args = parser.parse_args()
    graph_db = neo4j.GraphDatabaseService("http://{host}:{port}{path}".format(host=args.host, port=args.port, path=args.database_path))
    if args.format == "csv":
        execute_and_output_as_delimited(graph_db, args.query, ",")
    elif args.format == "geoff":
        execute_and_output_as_geoff(graph_db, args.query)
    elif args.format == "json":
        execute_and_output_as_json(graph_db, args.query)
    elif args.format == "tsv":
        execute_and_output_as_delimited(graph_db, args.query, "\t")
    else:
        execute_and_output_as_text(graph_db, args.query)
